kadai2.zip の説明

readme_kadai2.txt … このテキストファイル。プログラムの仕様、詳細説明など。

uni.h … UNIファイルの読み込み用関数やUNIevent構造体等を定義したプログラム。
unifilter.c … unifilter のプログラム本体。このファイルを各自で編集する。

test.uni … テスト用UNIデータ


◎課題2-1用
holy.uni … 「聖夜（きよしこの夜）」のUNIファイル
holy.jpg … 「聖夜」の楽譜の画像ファイル

◎課題2-2用
guntai.mid … 軍隊ポロネーズのMIDIファイル。windows付属のMedia Player等で聞ける。
guntai.uni … 軍隊ポロネーズのUNIファイル。
guntai.jpg … 軍隊ポロネーズの楽譜画像ファイル。これを見ながら元となるUNIデータを作成する。



● Visual C++でのプログラミングに関する補足

本実験では、Microsoft Visual Studio 2005 のパッケージ内の
Visual C++ （以下、VC++）を使用する。
（サンプルファイルはＣ言語で書かれているが、
　C++を用いても構わない。
　Ｃ言語で書かれたプログラムもVC++でコンパイル可能。）

Visual C++ を使用するのが初めての人のために、
使用方法に関して簡単な説明をしておく。


１．Visual C++ の起動方法

スタートメニュー → すべてのプログラム → Microsoft Visual Studio 2005
 → Microsoft Visual Studio 2005 を選択する。


２．ソースファイルをプロジェクトに追加・実行

　起動したVC++ のメニューバーから、以下の操作を行う。

ファイル → 新規作成 → プロジェクト を指定
新しいプロジェクト → プロジェクトの種類 → Win32、テンプレート → Win32コンソールアプリケーション
プロジェクト名、場所を適当に設定する
(たとえばデスクトップ上にunifilterというプロジェクトを設定したとする)
Win32アプリケーションウィザード → 次へ
→ アプリケーションの種類 → コンソールアプリケーション、追加のオプション → 空のオブジェクト → 完了
左のソルーションエクプローラでできたフォルダのソースファイル、ヘッダファイルのフォルダに各々unifilter.c、uni.hをdrag&drop
ビルド → ソリューション(またはunifilter)のビルド
ここで先ほど作成したunifilterフォルダの中のDebugフォルダにunifilter.exeが作成されていることを確認する。


３．unifilter.exe の実行

スタートメニュー → すべてのプログラム → アクセサリ → コマンドプロンプト　で、
コマンドプロンプトを呼び出す。

次に、コマンドプロンプト上で unifilter.exe があるディレクトリ（フォルダ）に移動する。

カレントディレクトリの移動には、cd コマンドを用いる。
また、カレントドライブの移動には、移動先ドライブレター +":"を使用する。
（例： H:\ から H:\jikken\ に移動するには、"cd jikken" と入力する。
       また、Hドライブ に移動する時は、"H:" と入力する。）

unifilter.exe と同じディレクトリにUNIファイルを用意し、
以下の様に打ち込むと、unifilter がUNIファイルを読み込んで
実行される。
　>unifilter uniファイル名


５．VC++での注釈文記述（コメントアウト）についての補足

VC++では、"/*"  と "*/" で囲んだ部分、または、、
"//" からその行の最後まではコメント扱いになる。
コメント扱いになった箇所は文字色が緑で表示される。

注：　// の前に全角スペースが含まれていると、
　  　コンパイラにコメント扱いされなくなるので注意。



●　uni.h の仕様について

プログラムソースと照らし合わせながら説明する。

------------------------
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
------------------------
標準ライブラリの読み込み。
stdlib.h は、atoi()を使用するために読み込む。


----------------------------
#define MAX_UNIEVENTS 1024
----------------------------
プログラムで扱えるunieventの最大数。ここでは1024とする。


----------------------
#define FLAG_ON 1
#define FLAG_OFF 0
----------------------
課題では無視して良い。



--------------------------------------------------------------
struct uni_event{
	long interval;   // ^I  インターバル
	int key_number;    // ^K  音高
	int velocity;   // ^V  ベロシティー
	int length;     // ^L  音の長さ
	int channel;    // ^W  声部
	int measure;    // ^M  小節
	int tempo;      // ^T  テンポ

	long position; // 曲開始からの位置（Σinterval）
};
--------------------------------------------------------------
UNIイベント１つ分（音符または小節線）を表す構造体。
UNIデータの１行分のテキストデータに相当する情報を格納する。
各メンバ変数はUNIフォーマットの仕様通りだが、
position は利便性の為に追加してある。
intervalが直前の音（又は小節線）からの相対時間なのに対し、
positionは曲の始めを０とする絶対時間を意味する。



-------------------------------------------------------
struct SUniEvent unievent[MAX_UNIEVENTS + 1];
-------------------------------------------------------
UNIイベントを格納する構造体を要素とする配列である。
load_uni()を実行すると、この配列にuniデータの情報が格納される。
なお、有効な配列要素は１からMAX_UNIEVENTS までであることに注意。
                      ~~~~~~~~~~~~~~~~~~~~~~~~


--------------------------
int n_unievents = 0;
--------------------------
unievent[]に格納されたUNIイベント数。
初期値は 0


--------------------------
void init_unievents();
--------------------------
unievent[]を初期化する。
unievent[]の初期化をすると、key_number には値 -1 が設定される。
これは、key_number = -1 の時、そのUNIイベントが音符でない事を表わしている。
UNIイベントが音符ならば、0 ≦ key_number ≦ 127 である。
また、channel（声部） は初期状態で 1 とする。


---------------------------
void display_unievents();
---------------------------
unievent[]の要素の各値を全て表示する。

（表示例）
   1 : [pos:    0] ^I   0 ^K -1 ^V  0 ^L   0 ^W 1 ^M  1 ^T  0
   2 : [pos:    0] ^I   0 ^K 74 ^V 80 ^L 170 ^W 1 ^M  0 ^T  0
   3 : [pos:    0] ^I   0 ^K 71 ^V 80 ^L 170 ^W 2 ^M  0 ^T  0
   4 : [pos:  180] ^I 180 ^K 76 ^V 80 ^L  50 ^W 1 ^M  0 ^T  0
   5 : [pos:  180] ^I   0 ^K 72 ^V 80 ^L  50 ^W 2 ^M  0 ^T  0
   6 : [pos:  240] ^I  60 ^K 74 ^V 80 ^L 110 ^W 1 ^M  0 ^T  0
   7 : [pos:  240] ^I   0 ^K 71 ^V 80 ^L 110 ^W 2 ^M  0 ^T  0
   8 : [pos:  360] ^I 120 ^K 71 ^V 80 ^L 350 ^W 1 ^M  0 ^T  0
   9 : [pos:  360] ^I   0 ^K 67 ^V 80 ^L 350 ^W 2 ^M  0 ^T  0
  10 : [pos:  720] ^I 360 ^K -1 ^V  0 ^L   0 ^W 1 ^M  2 ^T  0

（解説）
各行の数値について左から順に、
UNIイベント番号(ID), position, interval, key_number,
velocity, length, channel, tempo を表す。
この出力は、あくまでも確認用であり、UNIフォーマットとは異なる。



-------------------------------------------------------------------
int set_unievent_value(int n, const char *fieldname, int value );
-------------------------------------------------------------------
n 番目のUNIイベント(unievent[n])の、fieldnameで指定した文字に
対応するメンバ変数の値をvalueで置き換える。
メンバ変数のinterval はlong型だが、関数内部でキャストしている。
unievent[]が持つUNIイベント数(n_unievents)よりも n が大きい場合は、
「追加」とみなし、unievent[]の最後にイベントを加え、n_unieventsを１足す。

※ この関数は仕様がいい加減なので、課題で無理に利用する必要はない。
　 現時点ではload_uni()に実装されているのみである。

-------------------------------------------
int load_uni(const char *unifilename);
-------------------------------------------
unifilenameで指定したファイル名のUNIファイルを開き、
unievent[]に値を読み込む。
この際、n_unievents には読み込んだUNIイベント数が設定される。



● 課題で作成する unifilter.c の仕様について

uni.h は、uniデータの読み込み、初期化、値設定、表示用関数が予め定義されているが、
unifilter.c は各自で作成してもらう。

各自、以下の動作をするunifilter.exe を作成すること。


・引数

（書式）
>unifilter [unifile_name(*.uni)] [option] [event_start] [event_end] [value]

（引数の説明）
unifile_name : 入力UNIファイルを指定
option 　　　: 後述のフィルタ機能を文字で指定
event_start  : フィルタを適用する最初のUNIイベントの番号を指定
event_end 　 : フィルタを適用する最後のUNIイベントの番号を指定
value 　　　 :  各オプションのパラメータを指定



（option のフィルタ機能 とそれに対応するvalue の仕様）

＜option の文字＞　　　＜意味＞　＜value の定義域＞
 m (move key number)　　移調　　　　-12 〜 12
 v (velocity change)　強弱変更　　　10 〜1000 [%]
 t (tempo change)　　　速度変更　　　10 〜1000 [%]
 s (staccato)　　　　スタッカート　（valueを用いても用いなくても良い）
 l (legato)　　　　　　レガート　　（valueを用いても用いなくても良い）
 d (delete)　　　　　　　削除　　　　　 無し


例）　 >unifilter test.uni m 5 20 12

解説）	test.uni というuniファイルの、
	UNIイベント番号で5から20の音を１オクターブ(＝12半音）上げる。



　＜ option の意味と機能の解説 ＞

移調 … 指定したUNIイベントの音高(key)を一様に変更。
　　　　+1で音高を半音上げ、-1で音高を半音下げる。
　　　　フィルタリング中にkeyが値域を越えてはならない。
　　　　これは移調ではなく、メロディーの輪郭そのものが変化してしまうからである。

音の強弱 … 指定したUNIイベントの音の強さ(velocity)を一様に変更。
　　　　　　ここでは比率指定(%)とする。
　　　　　　ただし、最大値、最小値には注意。

速度変更 … 速度(tempo)を変更する。ここでは比率指定(%)とする。
　　　　　　速度変更のフィルタの実現にUNIフォーマット のフィールドT(Tempo)を
　　　　　　使用してはならない。フィールドLとIを変更する方法を採用すること。

スタッカート … 音を短く切る演奏にする。
　　　　　　　　フィールド L の値を現在の値より相対的に小さくする事で実現する。
　　　　　　　　引数 で value を用いるかどうかは各自の判断に任せる。
　　　　　　　　元の音符の長さ（音価）がフィルタ適用後のデータに
　　　　　　　　反映されるように考慮すること。（定数にしないこと）

レガート … 音をなめらかに繋げるように演奏する。
　　　　　　フィールドL の値を現在の値より相対的に大きくする事で実現する。

　　　補足：　このフィルタは同じ音高の音が連続して続く場合に、
　　　　　　　MIDIメッセージ（課題３を参照）の仕様により
　　　　　　　UNIデータの再生が意図したものにならなくなる。
　　　　　　　原因を考え、解決案を考えてみてほしい。


削除 … 指定した範囲のUNIイベントを削除する。
　　　　但し、小節線を表わすUNIイベントは削除せず、
　　　　音符を表わすイベントだけを削除すること。


なお、後述の課題2-1では小節ごとにフィルタをかけるように指定してあるが、
unifilter.exe はUNIイベント番号（行数）で指定する仕様にする事。



●　課題２−１

フィルタプログラム unifilter.exe を作成し、
それを用いて holy.uni に以下の変更を加えよ。
 m (move key number)　　移調　　　　-12 〜 12
 v (velocity change)　強弱変更　　　10 〜1000 [%]
 t (tempo change)　　　速度変更　　　10 〜1000 [%]
 s (staccato)　　　　スタッカート　（valueを用いても用いなくても良い）
 l (legato)　　　　　　レガート　　（valueを用いても用いなくても良い）
 d (delete)　　　　　　　削除　　　　　 無し

----（フィルタリングの詳細）---------------------------------------------

　ハ長調であるholy.uniを、ト長調に移調する（keyの値を７半音上げる）。

　１〜　２小節：音量を20%下げる
　３〜　６小節：音量を10%下げる
　９〜１０小節：音量を10%上げる
１１〜１２小節：音量を20%上げる

　５〜　６小節：スタッカートフィルタをかける
　７〜　８小節：レガートフィルタをかける

　７〜　９小節：速度を10%上げる
　　　１１小節：速度を10%下げる
　　　１２小節：速度を20%下げる

　　　８小節目：下のパート（声部２）を削除

----------------------------------------------------------------

レポートの内容：
・プログラムの仕様
・プログラムリスト
・実行結果（UNIファイルを含む）

レポートを書く時は、他人が見た時にプログラムの内容を理解でき、
かつ、その実験を再現できるように丁寧にまとめる事。

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

●　課題２−２

【１】guntai.jpg の楽譜を解析し、UNIデータをテキストエディタを用いて作成せよ。
　　　但し、楽譜の右手部分の一番上の旋律部分だけUNIデータに直せばよい。
　　（赤い線が入ってないところも一番上の旋律は右手部である）


【２】楽譜から読み取れる音楽記号と、本研究室で解析されたルールに則って、
　　　【１】のUNIデータに表情を付加せよ。作成した unifilter.exe を使用する事。

　演奏ルール１：楽曲構造内部では、緩やかに始まり、中心に向かって次第に速くなり、
　　　　　　　　終端付近に向かって遅くなる。
　演奏ルール２：主導の位置の音は伸び、また、そのアナクルーズの後半は次第に長くなる。


【３】上記の表情とは別途に適当な表情を１つ自分で考え、UNIデータに表情を付加せよ。

　各ルールに対して、フィルタ操作（実行の経過）と、
　そのフィルタ操作への考察（理由）を加えたものをレポートに記せ。


課題の提出・質問などは mizutani@cs.tsukuba.ac.jp まで。

